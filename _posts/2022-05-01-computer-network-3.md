---
title: 计算机网络-03
tags: Network


---

# 第三章 运输层

运输层位于应用层和网络层之间， 是分层的网络体系结构的重要部分。 该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用 。 我们在本章采用的教学方法是 ， 交替地讨论运输层的原理和这些原理在现有的协议中是如何实现的 。与往常一样 ， 我们将特别关注因特网协议， 即 TCP 和 UDP 运输层协议 。



<!--more-->

## 3.1 概述和运输层服务

> 运输层负责[端到端](https://baike.baidu.com/item/端到端/8851783)的通信，既是七层模型中负责[数据通信](https://baike.baidu.com/item/数据通信/897073)的最高层，又是面向网络通信的低三层和面向信息处理的最高三层之间的中间层。运输层位于网络层之上、[会话层](https://baike.baidu.com/item/会话层/4329656)之下，它利用网络层子系统提供给它的服务去开发本层的功能，并实现本层对会话层的服务。【来源：[百度百科](https://baike.baidu.com/item/%E8%BF%90%E8%BE%93%E5%B1%82/9094793?fr=aladdin)】

运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信 （ logic communica­tion） 功能 。从应用程序的角度看，通过逻辑通信 ，运行不同进程的主机好像直接相连一样 ； 实际上 ，这些主机也许位于地球的两侧 ，通过很多路由器及多种不同类型的链路相连 。

![2022-05-01 21-17-11 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012118806.png/)

如图 3-1所示，运输层协议是在端系统中而不是在路由器中实现的 。 在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层**报文段 （ segment）**。

网络应用程序可以使用多种的运输层协议 。例如 ， 因特网有两种协议， 即 TCP 和UDP 。 每种协议都能为调用的应用程序提供一组不同的运输层服务。

### 3.1.1 运输层和网络层的关系

在协议栈中 ，运输层刚好位于网络层之上。 网络层提供了**主机之间**的逻辑通信 ，而运输层为运行在不同主机上的**进程之间**提供了逻辑通信。

> 我们用一个家庭类比来帮助分析上述差别。
>
> 考虑有两个家庭 ， 一家位于美国东海岸 ， 一家位于美国西海岸 ， 每家有 12 个孩子 。东海岸家庭的孩子们是西海岸家庭孩子们的堂兄弟姐妹 。 这两个家庭的孩子们喜欢彼此通信 ， 每个人每星期要互相写一封信 ， 每封信都用单独的信封通过传统的邮政服务传送 。 因此 ， 每个家庭每星期向另一家发送 144 封信。 （ 如果他们有电子邮件的话，这些孩子可以省不少钱！） 每一个家庭有个孩子负责收发邮件 ，西海岸家庭是 Ann 而东海岸家庭是 Bill 。每星期 Ann 去她的所有兄弟姐妹那里收集信件 ， 并将这些信件交到每天到家门口来的邮政服务的邮车上。 当信件到达西海岸家庭时 ， Ann 也负责将信件分发到她的兄弟姐妹手上。在东海岸家庭中的 Bill 也负责类似的工作。
>
> 在这个例子中 ，邮政服务为两个家庭间提供逻辑通信 ，邮政服务将信件从一家送往另一家 ，而不是从一个人送往另一个人。 在另一方面， Ann 和 Bill 为堂兄弟姐妹之间提供了逻辑通信 ， Arm 和 Bill 从兄弟姐妹那里收取信件或到兄弟姐妹那里交付信件。 注意到从堂兄弟姐妹们的角度来看， Ann 和 Bill 就是邮件服务 ， 尽管他们只是端到端交付过程的一部分 （ 即端系统部分 ） 。 在解释运输层和网络层之间的关系时 ，这个家庭的例子是一个非常好的类比 。
>
> + 应用层报文 = 信封上的字符
> + 进程 = 堂兄弟姐妹
> + 主机 （ 又称为端系统） = 家庭
> + 运输层协议 = Ann 和 Bill
> + 网络层协议 = 邮政服务 （ 包括邮车）
>
> 我们继续观察这个类比 。值得注意的是 ， Ann 和 Bill 都是在各自家里进行工作的； 例如 ， 他们并没有参与任何一个中间邮件中心对邮件进行分拣 ， 或者将邮件从一个邮件中心送到另一个邮件中心之类的工作。 类似地 ，运输层协议只工作在端系统中。 在端系统中 ，运输层协议将来自应用进程的报文移动到网络边缘（ 即网络层 ）， 反过来也是一样 ， 但对有关这些报文在网络核心如何移动并不作任何规定 。事实上 ， 如图 3-1 所示， 中间路由器既不处理也不识别运输层加在应用层报文的任何信息 。
>
> 我们还是继续讨论这两家的情况。 现在假定 Ann 和 Bill 外出度假 ， 另外一对堂兄妹（ 如 Susan 和 Harvey） 接替他们的工作 ， 在家庭内部进行信件的收集和交付工作。不幸的是 ， Susan 和 Harvey 的收集和交付工作与 Ann 和 Bill 所做的并不完全一样 。 由于年龄更小 ， Susan 和 Harvey 收发邮件的次数更少 ，而且偶尔还会丢失邮件 （ 有时是被家里的狗咬坏了 ） 。 因此 ， Susan 和 Harvey 这对堂兄妹并没有提供与 Ann 和 Bill 一样的服务集合 （ 即相同的服务模型 ） 。与此类似，计算机网络中可以安排多种运输层协议，每种协议为应用程序提供不同的服务模型 。

运输协议能够提供的服务常常受制于底层网络层协议的服务模型 。 如果网络层协议无法为主机之间发送的运输层
报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证 。

然而， 即使底层网络协议不能在网络层提供相应的服务 ，运输层协议也能提供某些服务。例如 ， 如我们将在本章所见， 即使底层网络协议是不可靠的， 也就是说网络层协议会使分组丢失 、 篡改和冗余 ，运输协议也能为应用程序提供可靠的数据传输服务。

### 3.1.2 因特网运输层概述

因特网为应用层提供了两种截然不同的可用运输层协议 。 

+ 一种是UDP （用户数据报协议）， 它为调用它的应用程序提供了一种不可靠 、 无连接的服务。
+ 另一种是 TCP （ 传输控制协议）， 它为调用它的应用程序提供了一种可靠的 、 面向连接的服务。

应用程序开发人员在生成套接字时必须指定是选择 UDP 还是选择 TCP 。

为了简化术语， 我们将运输层分组称为**报文段 ( segment)** 。 然而， 因特网文献(如RFC 文档)常将 UDP 的分组称为**数据报 ( data-gram )** 。 而这类因特网文献也将网络层分组称为数据报 ！ 在这里， 我们认为将 TCP 和 UDP 的分组统称为报文段 ，而将数据报名称保留给网络层分组不容易混淆 。

> 在对 UDP 和 TCP 进行简要介绍之前 ，简单介绍一下因特网的网络层。 因特网网络层协议有一个名字叫 IP, 即网际协议 。 IP为主机之间提供了逻辑通信。 IP 的服务模型是**尽力而为交付服务( best- effort delivery serv­ice)** 。 这意味着 IP 尽它 “ 最大的努力” 在通信的主机之间交付报文段 ， 但它并不做任何确保。 特别是 ， 它不确保报文段的交付 ， 不保证报文段的按序交付 ， 不保证报文段中数据的完整性 。 由于这些原因 ， IP 被称为**不可靠服务 ( unreliable service)** 。 在此还要指出的是，每台主机至少有一个**网络层地址** ， 即所谓的 **IP 地址** ，每台主机有一个 IP 地址 。

UDP 和 TCP 最基本的责任是 ， 将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。 将主机间交付扩展到进程间交付被称为运输层的**多路复用（transport-layer multiplexing）** 与**多路分解(demultiplexing)** 。

UDP 和 TCP 还可以通过在其报文段首部中包括差错检查字段而提供完整性检查 。

进程到进程的数据交付和差错检查是两种最低限度的运输层服务 ， 也是UDP 所能提供的仅有的两种服务。

TCP 为应用程序提供了几种附加服务：

+ **可靠数据传输（reliable data transfer）。** 通过使用流量控制、 序号、 确认和定时器，TCP 确保正确地 、 按序地将数据从发送进程交付给接收进程 。
+ **拥塞控制 ( comgestion control ) 。**TCP 拥塞控制防止任何一条 TCP 连接用过多流量来淹没通信主机之间的链路和交换设备 。 TCP 力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽 。 这可以通过调节 TCP 连接的发送端发送进网络的流量速率来做到。



## 3.2 多路复用与多路分解

运输层的多路复用与多路分解是将由网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务。需要强调的是 ， 多路复用与多路分解服务是所有计算机网络都需要的 。

在目的主机 ，运输层从紧邻其下的网络层接收报文段 。 运输层负责将这些报文段中的数据交付给在主机上运行的适当应用程序进程 。 我们来看一个例子 。假定你正坐在计算机前下载 Web 页面， 同时还在运行一个 FTP 会话和两个 Telnet 会话 。 这样你就有 4 个网络应用进程在运行， 即两个 Telnet 进程， 一个 FTP 进程和一个 HTTP 进程 。 当你的计算机中的运输层从底层的网络层接收数据时 ， 它需要将所接收到的数据定向到这 4 个进程中的一
个。 现在我们来研究这是怎样完成的 。

首先回想 第2章的内容 ， 一个进程(作为网络应用的一部分)有一个或多个**套接字(socket)**， 它相当于从网络向进程传递数据和从进程向网络传递数据的门户 。 因此 ， 如图 3-2 所示， 在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字 。 由于在任一时刻 ， 在接收主机上可能有不止一个套接字 ， 所以每个套接字都有唯一的标识符 。 标识符的格式取决于它是 UDP 还是 TCP 套接字 ， 我们将很快对它们进行讨论 。



![2022-05-01 22-28-43 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012228650.png/)

现在我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字 。为此目的， 每个运输层报文段中具有几个字段 。 在接收端，运输层检查这些字段 ， 标识出接收套接字 ，进而将报文段定向到该套接字 。 将运输层报文段中的数据交付到正确的套接字的工作称为**多路分解 ( demultiplexing)** 。 在源主机从不同套接字中收集数据块 ， 并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段 ， 然后将报文段传递到网络层 ， 所有这些工作称为**多路复用 ( multiplexing)** 。

通过上述讨论， 我们知道运输层多路复用要求 ： ①套接字有唯一标识符；②每个报文段有特殊字段来指示该报文段所要交付到的套接字 。

![2022-05-01 22-37-51 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012238859.png/)

如图3-3所示，这些特殊字段是**源端口号字段 ( source port number field )** 和目**的端口号字段 ( destination port number field)** 。

端口号是一个 16 比特的数 ， 其大小在 0 ~ 65535 之间 。 0 ~ 1023 范围的端口号称为**周知端口号( well-known port number)**，是受限制的，这是指它们保留给诸如 HTTP (它使用端口号 80) 和 FTP (它使用端口号 21) 之类的周知应用层协议来使用 。

现在应该清楚运输层是怎样能够实现分解服务的了 ： 在主机上的每个套接字能够分配一个端口号 ， 当报文段到达主机时 ，运输层检査报文段中的目的端口号 ， 并将其定向到相应的套接字 。 然后报文段中的数据通过套接字进入其所连接的进程 。 如我们将看到的那样 ， UDP 大体上是这样做的 。 然而， 也将如我们所见， TCP 中的多路复用与多路分解更为复杂 。

1. **无连接的多路复用与多路分解**

   假定在主机 A 中的一个进程具有 UDP 端口 19157, 它要发送一个应用程序数据块给位于主机B 中的另一进程，该进程具有 UDP 端口 46428。主机 A 中的运输层创建一个运输层报文段 ， 其中包括应用程序数据 、 源端口号 （ 19157 ） 、 目的端口号 （ 46428 ） 和两个其他值。 然后 ，运输层将得到的报文段传递到网络层 。 网络层将该报文段封装到一个 IP数据报中 ， 并尽力而为地将报文段交付给接收主机 。如果该报文段到达接收主机 B, 接收主机运输层就检查该报文段中的目的端口号 （ 46428 ）并将该报文段交付给端口号46428 所标识的套接字 。值得注意的是 ， 主机 B 可能运行多个进程， 每个进程都具有其自己的 UDP 套接字和相联系的端口号。 当 UDP 报文段从网络到达时 ， 主机 B 通过检查该报文段中的目的端口号 ， 将每个报文段定向 （ 分解） 到相应的套接字 。

   一个 UDP 套接字是由一个二元组全面标识的，该二元组包含一个目的IP 地址和一个目的端口号。 因此，如果两个 UDP 报文段有不同的源 IP 地址和/ 或源端口号 ， 但具有相同的目的 IP 地址和目的端口号 ，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程 。

   源端口号的用途是什么呢 ？ 如图 3-4 所示， 在 A 到 B 的报文段中，源端口号用作“ 返回地址"的一部分 ， 即当 B 需要回发一个报文段给 A 时 ， B 到 A 的报文段中的目的端口号便从 A 到 B 的报文段中的源端口号中取值。 （ 完整的返回地址是 A 的 IP 地址和源端口号。 ）

   

![2022-05-01 22-46-53 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012247189.png/)

2. **而向连接的多路复用与多路分解**

   TCP 套接字是由一个四元组（ **源 IP 地址，源端口号 ，目的 IP 地址 ，目的端口号** ） 来标识的 。 因此 ， 当一个 TCP 报文段从网络到达一台主机时 ，该主机使用全部 4 个值来将报文段定向 （ 分解） 到相应的套接字 。 特别与UDP 不同的是 ， 两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字 ，除非 TCP 报文段携带了初始创建连接的请求 。

   服务器主机可以支持很多并行的 TCP 套接字 ， 每个套接字与一个进程相联系， 并由其四元组来标识每个套接字 。 当一个 TCP 报文段到达主机时 ， 所有 4 个字段 （ 源 IP 地址,源端口 ，目的 IP 地址 ，目的端口 ）被用来将报文段定向 （ 分解） 到相应的套接字 。

   图 3-5 图示了这种情况 ， 图中主机 C 向服务器 B 发起了两个 HTTP 会话， 主机 A 向服务器 B 发起了一个 HTTP 会话 。主机 A 与主机 C 及服务器 B 都有自己唯一的 IP 地址 ， 它们分别是 A 、 C 、 B 。 主机 C 为其两个 HTTP 连接分配了两个不同的源端口号 （ 26145 和7532 ） 。 因为主机 A 选择源端口号时与主机 C 互不相干 ， 因此它也可以将源端口号 26145分配给其 HTTP 连接 。但这不是问题， 即服务器 B 仍然能够正确地分解这两个具有相同源端口号的连接 ， 因为这两条连接有不同的源 IP 地址 。

![2022-05-01 22-59-34 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012259877.png/)

## 3.3 无连接运输

UDP 从应用进程得到数据 ，附加上用于多路复用 /分解服务的源和目的端口号字段 ， 以及两个其他的小字段,
然后将形成的报文段交给网络层 。 网络层将该运输层报文段封装到一个 IP 数据报中 ， 然后尽力而为地尝试将此报文段交付给接收主机 。 如果该报文段到达接收主机 ， UDP 使用目的端口号将报文段中的数据交付给正确的应用进程 。值得注意的是 ， 使用 UDP 时 ， 在发送报文段之前 ， 发送方和接收方的运输层实体之间没有握手 。 正因为如此 ， UDP 被称为是**无连接的** 。

DNS 是一个通常使用 UDP 的应用层协议的例子 。 当一台主机中的 DNS 应用程序想要进行一次查询时 ， 它构造了一个 DNS 查询报文并将其交给 UDP 。 无须执行任何与运行在目的端系统中的 UDP 实体之间的握手 ， 主机端的 UDP 为此报文添加首部字段 ， 然后将形成的报文段交给网络层。 网络层将此 UDP 报文段封装进一个 IP 数据报中 ， 然后将其发送给一个名字服务器。 在查询主机中的 DNS 应用程序则等待对该查询的响应 。 如果它没有
收到响应 （ 可能是由于底层网络丢失了查询或响应 ）， 则要么试图向另一个名字服务器发送该査询，要么通知调用的应用程序它不能获得响应 。

UDP相比于TCP的优点

+ **关于发送什么数据以及何时发送的应用层控制更为精细 。**
+ **无须连接建立 。**
+ **无连接状态 。**
+ **分组首部开销小 。**

### 3.3.1 UDP报文段结构

UDP 报文段结构如图 3-7 所示， 它由 RFC 768 定义。 应用层数据占用 UDP 报文段的数据字段 。

![2022-05-02 14-14-01 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205021414539.png/)

UDP 首部只有 4 个字段 ， 每个字段由两个字节组成 。 如前一节所讨论的，通过**端口号**可以使目的主机将应用数据交给运行在目的端系统中的相应进程（ 即执行分解功能） 。 **长度字段**指示了在 UDP 报文段中的字节数 （首部加数据 ） 。 因为数据字段的长度在一个 UDP 段中不同于在另一个段中 ， 故需要一个明确的长度 。接收方使用**检验和**来检查在该报文段中是否出现了差错 。 实际上 ，计算检验和时 ，除了 UDP 报文段以外还包括了 IP 首部的一些字段 。

### 3.3.2 UDP检验和

UDP 检验和提供了差错检测功能 。 这就是说， 检验和用于确定当 UDP 报文段从源到达目的地移动时 ， 其中的比特是否发生了改变 。发送方的 UDP 对报文段中的所有 16 比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。 得到的结果被放在 UDP 报文段中的检验和字段 。

举例来说， 假定我们有下面 3个 16 比特的字 ：

> 0110011001100000
>
> 0101010101010101
>
> 1000111100001100

这些 16 比特字的前两个之和是 ：

> 0110011001100000
>
> 0101010101010101
>
> ____________________
>
> 1011101110110101

再将上面的和与第三个字相加 ， 得出 ：

> 1011101110110101
>
> 1000111100001100
>
> ----------------------------------
>
> 0100101011000010

注意到最后一次加法有溢出 ， 它要被回卷。反码运算就是将所有的 0 换成 1， 所有的1 转换成 0 。 因此,该和 0100101011000010 的反码运算结果是 1011010100111101, 这就变为了检验和。 在接收方 ， 全部的 4 个 16 比特字 （ 包括检验和 ） 加在一起 。 如果该分组中没有引入差错， 则显然在接收方处该和将是1111111111111111 。如果这些比特之一是 0，那么我们就知道该分组中已经出现了差错 。

你可能想知道为什么 UDP 首先提供了检验和 ， 就像许多链路层协议（ 包括流行的以太网协议） 也提供了差错检测那样 。其原因是不能保证源和目的之间的所有链路都提供差错检测 ；这就是说， 也许这些链路中的一条可能使用没有差错检测的协议 。 此外 ， 即使报文段经链路正确地传输， 当报文段存储在某台路由器的内存中时 ， 也可能引入比特差错 。在既无法确保逐链路的可靠性 ， 又无法确保内存中的差错检测的情况下 ， 如果端到端数据传输服务要提供差错检测 ， UDP 就必须在端到端基础上在运输层提供差错检测 。 这是一个在系统设计中被称颂的**端到端原则 （ end-encl principle）** 的例子,该原则表述为因为某种功能（ 在此时为差错检测 ） 必须基于端到端实现： “与在较高级别提供这些功能的代价相比 ，在较低级别上设置的功能可能是冗余的或几乎没有价值的 。”



## 3.4 可靠数据传输原理

图 3-8 图示说明了我们学习可靠数据传输的框架 。为上层实体提供的服务抽象是 ： 数据可以通过一条可靠的信道进行传输 。借助于可靠信道， 传输数据比特就不会受到损坏（由 0 变为 1, 或者相反 ） 或丢失 ，而且所有数据都是按照其发送顺序进行交付。 这恰好就是 TCP 向调用它的因特网应用所提供的服务模型 。



![2022-05-02 19-52-15 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205021952803.png/)

实现这种服务抽象是**可靠数据传输协议（ reliable data transfer protocol ）**的责任。 由于可靠数据传输协议的下层协议也许是不可靠的， 因此这是一项困难的任务。例如 ， TCP 是在不可靠的 （ IP） 端到端网络层之上实现的可靠数据传输协议 。 更一般的情况是 ， 两个可靠通信端点的下层可能是由一条物理链路（ 如在链路级数据传输协议的场合下 ）组成或是由一个全球互联网络（ 如在运输级协议的场合下 ）组成 。 然而， 就我们的目的而言， 我们可将较低层直接视为不可靠的点对点信道 。

在本节中 ，考虑到底层信道模型越来越复杂 ， 我们将不断地开发一个可靠数据传输协议的发送方一侧和接收方一侧。例如 ， 我们将考虑当底层信道能够损坏比特或丢失整个分组时 ，需要什么样的协议机制。 这里贯穿我们讨论始终的一个假设是分组将以它们发送的次序进行交付 ， 某些分组可能会丢失 ；这就是说， **底层信道将不会对分组重排序** 。 图 3-8b说明了用于数据传输协议的接口。 通过调用`rdt_send ()` 函数 ， 上层可以调用数据传输
协议的发送方 。 它将要发送的数据交付给位于接收方的较高层 。(这里 rdt 表示可靠数据传输协议， _send 指示 rdt 的发送端正在被调用 。 )在接收端， 当分组从信道的接收端到达时 ， 将调用 `rdt_rcv()` 。当 rdt 协议想要向较高层交付数据时 ， 将通过调用`deliver_data()` 来完成 。

在本节中 ， 我们仅考虑**单向数据传输 （unidirectional data transfer）** 的情况 ， 即数据传输是从发送端到接收端的 。可靠的**双向数据传输 （bidirectional data transfer）** （即全双工数据传输）情况从概念上讲不会更难， 但解释起来更为单调乏味。 虽然我们只考虑单向数据传输， 注意到下列事实是重要的， 我们的协议也需要在发送端和接收端两个方向上传输分组， 如图 3-8 所示 。 我们很快会看到 ，除了交换含有待传送的数据的分组之外 ， rdt 的发送端和接收端还需往返交换控制分组 。 rdt 的发送端和接收端都要通过调用 `udt_send() `发送分组给对方(其中 udt 表示不可靠数据传输)。

### 3.4.1 构造可靠数据传输协议

+ **经完全可靠信道的可靠数据传输： rdt1. 0**

  ![2022-05-02 20-05-33 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205022005779.png/)

  首先 ， 我们考虑最简单的情况 ， 即底层信道是完全可靠的 。 我们称该协议为 rdt1.0，该协议本身是简单的 。 图 3-9 显示了 rdt1.0 发送方和接收方的**有限状态机 （Finite-State Machine , FSM）** 的定义。图 3-9a 中的 FSM定义了发送方的操作 ， 图 3-9b 中的 FSM 定义了接收方的操作。 注意到下列问题是重要的， 发送方和接收方有各自的 FSM 。 图 3-9中发送方和接收方的 FSM 每个都只有一个状态 。 FSM 描述图中的箭头指示了协议从一个状态变迁到另一个状态 。因为图 3-9 中的每个 FSM 都只有一个状态 ， 因此变迁必定是从一个状态返回到自身。引起变迁的事件显示在表示变迁的横线上方 ， 事件发生时所采取的动作显示在横线下方 。 如果对一个事件没有动作，或没有就事件发生而采取了一个动作 ， 我们将在横线上方或下方使用符号$\Lambda$​，以分别明确地表示缺少动作或事件。FSM 的初始状态用虚线表示 。 尽管图3-9中的 FSM 只有一个状态 ， 但马上我们就将看到多状态的 FSM, 因此标识每个 FSM 的初始状态是非常重要的 。
  
  rdt 的发送端只通过` rdt_send(data) `事件接受来自较高层的数据 ， 产生一个包含该数据的分组(经由` make-pkt (data)` 动作， 并将分组发送到信道中。 实际上 ，`rdt_send(data)` 事件是由较高层应用的过程调用产生的 ( 例如 ， `rdcsend() `) 。
  
  在接收端，rdt通过`rdt_rcv(packet)`事件从底层信道接收一个分组， 从分组中取岀数据（经由 `extract(packet,data) `动作）， 并将数据上传给较高层（通过 `deliver_data( data )` 动作）。实际上 ， `rdt_rcv( packet)` 事件是由较低层协议的过程调用产生的（例如 ， `rdt_rcv()` ） 。
  
  在这个简单的协议中 ， 一个单元数据与一个分组没差别。 而且 ， 所有分组是从发送方流向接收方 ； 有了完全可靠的信道， 接收端就不需要提供任何反馈信息给发送方 ， 因为不必担心出现差错！ 

+ **经具有比特差错信道的可靠数据传输:  rdt2.0**

  底层信道更为实际的模型是分组中的比特可能受损的模型 。 在分组的传输 、传播或缓存的过程中 ，这种比特差错通常会岀现在网络的物理部件中。 我们眼下还将继续假定所有发送的分组(虽然有些比特可能受损)将按其发送的顺序被接收 。

  考虑一下你自己是怎样通过电话口述一条长报文的 。 在通常情况下 ， 报文接收者在听到、 理解并记下每句话后可能会说 “0K” 。 如果报文接收者听到一句含糊不清的话时，他可能要求你重复那句容易误解的话 。 这种口述报文协议使用了**肯定确认 ( positive acknowledgment )( "OK” )** 与**否定确认 ( negative acknowledgment)( "请重复一遍)**。 这些控制报文使得接收方可以让发送方知道哪些内容被正确接收 ， 哪些内容接收有误并因此需要重复 。 在计算机网络环境中 ， 基于这样重传机制的可靠数据传输协议称为**自动重传请求( Automatic Repeat Request , ARQ) 协议** 。

  > 重要的是 ， ARQ 协议中还需要另外三种协议功能来处理存在比特差错的情况 ：
  >
  > + **差错检测 。**首先 ，需要一种机制以使接收方检测到何时出现了比特差错 。
  > + **接收方反馈 。**我们的rdt2.0 协议将从接收方向发送方回送 ACK 与 NAK 分组 。 理论上 ，这些分组只需要一个比特长；如用 0 表示 NAK,，用 1 表示 ACK。
  > + **重传。**接收方收到有差错的分组时 ， 发送方将重传该分组文 。
  
  ![2022-05-02 23-29-57 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205022330208.png/)
  
  图 3-10 说明了表示 rdt2.0 的 FSM, 该数据传输协议采用了差错检测 、 肯定确认与否定确认 。
  
  rdt2.0 的发送端有两个状态 。 在最左边的状态中 ， 发送端协议正等待来自上层传下来的数据 。 当 `rdt_send(data)` 事件岀现时 ， 发送方将产生一个包含待发送数据的分组 ( sndpk)，带有检验和(例如 ， 就像在 3.3.2 节讨论的对 UDP 报文段使用的方法) ， 然后经由`udt_send(sndpkt)` 操作发送该分组 。 在最右边的状态中 ， 发送方协议等待来自接收方的ACK 或 NAK 分组 。 如果收到一个 ACK 分组（图 3-10 中符号 `rdt_rcv( rcvpkt) && isACK(rcvpkt)` 对应该事件) ， 则发送方知道最近发送的分组已被正确接收 ，因此协议返回到等待来自上层的数据的状态 。 如果收到一个 NAK 分组，该协议重传上一个分组并等待接收方为响应重传分组而回送的 ACK 和 NAKO 注意到下列事实很重要： 当发送方处于等待ACK 或 NAK 的状态时 ，它不能从上层获得更多的数据 ；这就是说， `rdt_send ()` 事件不可能岀现； 仅当接收到 ACK 并离开该状态时才能发生这样的事件。 因此 ， 发送方将不会发送一块新数据 ，除非发送方确信接收方已正确接收当前分组 。由于这种行为 ， rdt2.0 这样的协议被称为**停等 ( stop-and-wait)** 协议 。
  
  rdt2.0 接收方的 FSM 仍然只有单一状态 。 当分组到达时 ， 接收方要么回答一个 ACK，要么回答 一个NAK， 这取决于收到的分组是否受损 。 在图 3-10 中 ，符号 `rdt_rcv ( rcvpkt ) &&corrupt ( rcvpkt)` 对应于收到一个分组并发现有错的事件。
  
  rdt2.0 协议存在一个致命的缺陷 ：没有考虑到 ACK 或 NAK 分组受损的可能性！这里的难点在于 ， 如果一个 ACK 或 NAK 分组受损 ， 发送方无法知道接收方是否正确接收了上一块发送的数据 。
  
  > 考虑处理受损 ACK 和 NAK 时的 3 种可能性:
  >
  > + 对于第一种可能性 ，考虑在口述报文情况下人可能的做法 。重复询问。
  > + 第二种可能性是增加足够的检验和比特， 使发送方不仅可以检测差错，还可恢复差错 。 对于会产生差错但不丢失分组的信道，这就可以直接解决问题 。
  > + 第三种方法是 ， 当发送方收到含糊不清的 ACK 或 NAK 分组时 ， 只需重传当前数据分组即可。 然而，这种方法在发送方到接收方的信道中引入了**冗余分组（ dupli­cate packet ）**。冗余分组的根本困难在于接收方不知道它上次所发送的 ACK 或 NAK是否被发送方正确地收到。
  
  解决这个新问题的一个简单方法是在数据分组中添加一新字段 ，让发送方对其数据分组编号 ， 即将发送数
  据分组的**序号 （ sequence number）** 放在该字段 。于是 ， 接收方只需要检查序号即可确定收到的分组是否一次重传。 对于停等协议这种简单情况 ， 1 比特序号就足够了 ， 因为它可让接收方知道发送方是否正在重传前一个发送分组（ 接收到的分组序号与最近收到的分组序号相同 ）， 或是一个新分组（ 序号变化了 ，用模 2 运算 “前向” 移动 ） 。 因为目前我们假定信道不丢分组， ACK 和 NAK 分组本身不需要指明它们要确认的分组序号。发送方知道所接收到的 ACK 和 NAK 分组（ 无论是否是含糊不清的） 是为响应其最近发送的数据分组而生成的 。
  
  图 3 -11 和图 3-12 给出了对 rdt2.1 的 FSM 描述，这是rdt2.0的修订版 。 rdt2.1的发送方和接收方 FSM 的状态数都是以前的两倍。 这是因为协议状态此时必须反映出目前 （由发送方 ） 正发送的分组或 （ 在接收方 ） 希望接收的分组的序号是 0 还是 1 。值得注意的是 ， 发送或期望接收 0 号分组的状态中的动作与发送或期望接收 1 号分组的状态中的动作是相似的； 唯一的不同是序号处理的方法不同。
  
  协议 rdt2.1 使用了从接收方到发送方的肯定确认和否定确认 。 当接收到失序的分组时 ， 接收方对所接收的分组发送一个肯定确认 。 如果收到受损的分组， 则接收方将发送一个否定确认 。 如果不发送 NAK, 而是对上次正确接收的分组发送一个 ACK, 我们也能实现与 NAK — 样的效果 。发送方接收到对同一个分组的两个 ACK （ 即接收**冗余 ACK（duplicate ACK）**） 后 ， 就知道接收方没有正确接收到跟在被确认两次的分组后面的分组 。rdt2.2 是在有比特差错信道上实现的一个无 NAK 的可靠数据传输协议，如图 3-13 和图 3-14 所示 。 rdt2. 1 和 rdt2.2 之间的细微变化在于 ， 接收方此时必须包括由一个 ACK 报文所确认的分组序号(这可以通过在接收方 FSM 中 ， 在 `make_pkt ()` 中包括参数 ACK 0 或 ACK 1 来实现) ， 发送方此时必须检查接收到的ACK 报文中被确认的分组序号(这可通过在发送方 FSM 中 ， 在 `isACK()` 中包括参数 0 或 1 来实现)。

![2022-05-03 00-01-36 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205030001022.png/)

![2022-05-03 00-02-23 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205030002659.png/)

+ **经具有比特差错的丢包信道的可靠数据传输： rdt3.0**

  现在假定除了比特受损外 ， 底层信道还会丢包 。协议现在必须处理另外两个关注的问题： **怎样检测丢包**以及**发生丢包后该做些什么**。 在 rdt2.2 中已经研发的技术 ， 如使用检验和、 序号、 ACK 分组和重传等， 使我们能给出后一个问题的答案 。为解决第一个关注的问题，还需增加一种新的协议机制。

  这里， 我们让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对该分组的 ACK 发生了丢失 。 在这两种情况下 ， 发送方都收不到应当到来的接收方的响应 。 如果发送方愿意等待足够长的时间以便确定分组已丢失 ， 则它只需重传该数据分组即可。、

  但是发送方需要等待多久才能确定已丢失了某些东西呢 ？ 很明显发送方至少需要等待这样长的时间： 即发送方与接收方之间的一个往返时延 （ 可能会包括在中间路由器的缓冲时延 ） 加上接收方处理一个分组所需的时间 。 在很多网络中 ， 最坏情况下的最大时延是很难估算的，确定的因素非常少 。 此外 ，理想的协议应尽可能快地从丢包中恢复出来 ；等待一个最坏情况的时延可能意味着要等待一段较长的时间，直到启动差错恢复为止 。 因此实践中采取的方法是发送方明智地选择一个时间值 ， 以判定可能发生了丢包 （ 尽管不能确保 ） 。 如果在这个时间内没有收到 ACK，则重传该分组 。 注意到如果一个分组经历了一个特别大的时延 ， 发送方可能会重传该分组， 即使该数据分组及其 ACK 都没有丢失 。 这就在发送方到接收方的信道中引入了冗**余数据分组（ duplicate data packet ）** 的可能性 。 幸运的是 ， rdt2.2 协议已经有足够的功能（ 即序号 ） 来处理冗余分组情况。

  发送方不知道是一个数据分组丢失 ，还是一个 ACK 丢失 ， 或者只是该分组或 ACK 过度延时 。 在所有这些情况下 ， 动作是同样的：**重传**。为了实现基于时间的重传机制 ，需要一个**倒计数定时器 （ countdown timer）** , 在一个给定的时间量过期后 ， 可中断发送方 。 因此 ， 发送方需要能做到 ： ①每次发送一个分组（ 包括第一次分组和重传分组） 时 ， 便启动一个定时器。②响应定时器中断 （采取适当的动作 ） 。③终止定时器。

  ![2022-05-03 12-49-18 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205031249462.png/)

  图 3-15 给出了 rdt3. 0 的发送方 FSM，这是一个在可能出错和丢包的信道上可靠传输数据的协议。图 3-16 显示了在没有丢包和延迟分组情况下协议运作的情况 ， 以及它是如何处理数据分组丢失的 。 在图 3-16 中 ， 时间从图的顶部朝底部移动 ； 注意到一个分组的接收时间必定迟于一个分组的发送时间，这是因为发送时延与传播时延之故 。 在图 3-16b ~ d 中 ， 发送方括号部分表明了定时器的设置时刻以及随后的超时 。 。 因为分组序号在 0 和 1 之间交替 ， 因此 rdt3.0 有时被称为**比特交替协议 （ alternating- bit protocol)** 。

![2022-05-03 12-51-08 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205031251231.png/)

### 3.4.2 流水线可靠数据传输协议

rdt3.0 是一个功能正确的协议， 但并非人人都对它的性能满意 ，特别是在今天的高速网络中更是如此 。 rdt3.0 性能问题的核心在于它是一个停等协议 。

为了评价该停等行为对性能的影响 ， 可考虑一种具有两台主机的理想化场合 ， 一台主机位于美国西海岸 ， 另一台位于美国东海岸 ， 如图 3-17 所示 。 在这两个端系统之间的光速往返传播时延 RTT 大约为 30 毫秒 。假定彼此通过一条发送速率 R 为 1Gbps （ 每秒$10^{9}$比特）的信道相连 。包括首部字段和数据的分组长$L$为 1000 字节（ 8000 比特）， 发送一个分组进入 1Gbps 链路实际所需时间是 ：

$$t_{trans}=\frac{L}{R}=\frac{8000bit/pkt}{10^{9}bit/s}=8\mu s/pkt$$

![2022-05-03 12-56-56 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205031257263.png/)

![image-20220503132111796](https://gitee.com/cafory/images-store/raw/master/Image/202205031321917.png/)



图 3-18a 显示了对于该停等协议， 如果发送方在$t=0$时刻开始发送分组， 则在 $t=L/R=8\mu s$ 后 ， 最后 1 比特数据进入了发送端信道 。 该分组经过 15ms 的穿越国家的旅途后到达接收端，该分组的最后 1 比特在时刻 $t=RTT/2+L/R=15.008\mu s$ 时到达接收方 。为了简化起见， 假设 ACK 分组很小 （ 以便我们可以忽略其发送时间）， 接收方一旦收到一个数据分组的最后 1 比特后立即发送 ACK，ACK 在时刻 $t=RTT/2+L/R=30.008\mu s$ 时在发送方出现 。 此时 ， 发送方可以发送下一个报文 。 因此 ， 30.008ms 内 ， 发送方的发送只用了0.008 ms。 如果我们定义发送方 （ 或信道）的**利用率 （ utilization）** 为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比 ， 图 3-18a 中的分析表明了停等协议有着非常低的发送方利用率 $U_{sender}$:

$$U_{sender}=\frac{L/R}{RTT+L/R}=\frac{0.008}{30.008}=0.00027$$

这就是说， 发送方只有万分之 2. 7 时间是忙的 。从其他角度来看， 发送方在 30. 008ms内只能发送 1000 字节， 有效的吞吐量仅为 267kbps，即使有 1Gbps 的链路可用也是如此！

这种特殊的性能问题的一个简单解决方法是 ： 不以停等方式运行， 允许发送方发送多个分组而无须等待确认， 如在图 3-17b 图示的那样 。 图 3-18b 显示了如果发送方可以在等待确认之前发送 3 个报文 ， 其利用率也基本上提高 3 倍。因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中 ， 故这种技术被称为**流水线 （ pipelining）** 。 流水线技术对可靠数据传输协议可带来如下影响：

+ 必须增加序号范围 ， 因为每个输送中的分组（ 不计算重传的） 必须有一个唯一的序号 ，而且也许有多个在输送中的未确认报文 。
+ 协议的发送方和接收方两端也许不得不缓存多个分组 。发送方最低限度应当能缓冲那些已发送但没有确认的分组 。 如下面讨论的那样 ， 接收方或许也需要缓存那些已正确接收的分组 。
+ 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失 、 损坏及延时过大的分组 。 解决流水线的差错恢复有两种基本方法是 ： **回退 N 步 （ Go-Back-N，GBN)** 和**选择重传( Selective Repeat , SR)** 。

### 3.4.3 回退N步

在**回退N步（ GBN）** 协议中 ， 允许发送方发送多个分组（ 当有多个分组可用时 ）而不需等待确认， 但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。 

图 3-19 显示了发送方看到的 GBN 协议的序号范围 。 如果我们将**基序号 （ base）** 定义为最早未确认分组的序号 ， 将**下一个序号 （ nextseqnum ）** 定义为最小的未使用序号 （ 即下一个待发分组的序号 ）， 则可将序号范围分割成 4 段 。 在 ［0， base - 1］ 段内的序号对应于已经发送并被确认的分组 。 ［base， nextseqnum - 1 ］段内对应已经发送但未被确认的分组 。 ［ nextseqnum , base + N - 1 ］ 段内的序号能用于那些要被立即发送的分组， 如果有数据来自上层的话 。最后 ， 大于或等于 base + N 的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为 base 的分组） 已得到确认为止 。

![image-20220503132639683](https://gitee.com/cafory/images-store/raw/master/Image/202205031326755.png/)

如图 3-19 所提示的那样 ，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为"的窗口。 随着协议的运行，该窗口在序号空间向前滑动。 因此 ，N常被称为**窗口长度（ window size ）**， GBN 协议也常被称为**滑动窗口协议（ sliding-window protocol）** 。

在实践中 ， 一个分组的序号承载在分组首部的一个固定长度的字段中。 如果分组序号字段的比特数是$k$ ，则该序号范围是 $[0, 2^{k}-1]$在一个有限的序号范围内 ， 所有涉及序号的运算必须使用模 $2^{k}$运算 。 （ 即序号空间可被看作是一个长度为$2^{k}$ 的环， 其中序号$2^{k}-1$ 紧接着序号 0 。 ）

图 3-20 和图 3-21 给出了一个基于 ACK 、 无 NAK 的 GBN 协议的发送方和接收方这两端的扩展 FSM 描述 。 我们称该 FSM 描述为**扩展 FSM**，是因为我们已经增加了变量 base 和 nextseqnum，还增加了对这些变量的操作以及与这些变量有关的条件动作。

![image-20220503133337417](https://gitee.com/cafory/images-store/raw/master/Image/202205031333541.png/)

GBN 发送方必须响应三种类型的事件 ：

+ **上层的调用 。**当上层调用 `rdt_send()`时 ， 发送方首先检查发送窗口是否已满 ， 即是否有 N 个已发送但未被确认的分组 。 如果窗口未满 ， 则产生一个分组并将其发送,并相应地更新变量 。 如果窗口已满 ， 发送方只需将数据返回给上层 ，隐式地指示上层该窗口已满 。 然后上层可能会过一会儿再试 。 在实际实现中 ， 发送方更可能缓存 （ 并不立刻发送）这些数据 ， 或者使用同步机制 （ 如一个信号量或标志 ） 允许上层在仅当窗口不满时才调用 `rdt_send()` 。
+ **收到一个 ACK 。**在 GBN 协议中 ， 对序号为几的分组的确认采取**累积确认（ cumu­lative acknowledgment ）** 的方式 ，表明接收方已正确接收到序号为 n 的以前且包括 n在内的所有分组 。
+ **超时事件。**协议的名字 “ 回退 N 步 ” 来源于出现丢失和时延过长分组时发送方的行为。 就像在停等协议中那样 ， 定时器将再次用于恢复数据或确认分组的丢失 。如果出现超时 ， 发送方重传所有已发送但还未被确认过的分组 。

在 GBN 中 ， 接收方的动作也很简单。 如果一个序号为$n$的分组被正确接收到 ， 并且按序 （ 即上次交付给上层的数据是序号为$n-1$的分组）， 则接收方为分组 $n$发送一个ACK, 并将该分组中的数据部分交付到上层 。 在所有其他情况下 ， 接收方丢弃该分组， 并为最近按序接收的分组重新发送 ACK 。 注意到因为一次交付给上层一个分组， 如果分组$k$已接收并交付 ， 则所有序号比$k$小的分组也已经交付。 因此 ， 使用累积确认是 GBN —个自然的选择 。

![image-20220503134111105](https://gitee.com/cafory/images-store/raw/master/Image/202205031341198.png/)

图 3-22 给岀了窗口长度为 4 个分组的 GBN 协议的运行情况。 因为该窗口长度的限制，发送方发送分组 0~3，然后在继续发送之前 ， 必须等待直到一个或多个分组被确认 。 当接收到每一个连续的 ACK （ 例如 ACK 0 和 ACK 1 ） 时，该窗口便向前滑动 ， 发送方便可以发送新的分组（ 分别是分组 4 和分组 5 ） 。 在接收方 ， 分组 2 丢失 ， 因此分组 3 、 4和 5 被发现是失序分组并被丢弃 。

### 3.4.4 选择重传

在图 3-17 中 ， GBN 协议潜在地允许发送方用多个分组 “ 填充流水线 ” ， 因此避免了停等协议中所提到的信道利用率问题 。 然而， GBN 本身也有一些情况存在着性能问题 。 尤其是当窗口长度和带宽时延积都很大时 ， 在流水线中会有很多分组更是如此 。单个分组的差错就能够引起 GBN 重传大量分组，许多分组根本没有必要重传。 随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥 。 想象一下 ， 在我们口述消息的例子中 ， 如果每次有一个单词含糊不清 ， 其前后 1000 个单词（ 例如 ，窗口长度为 1000 个单词） 不得不被重传的情况。 此次口述会由于这些反复述说的单词而变慢 。

顾名思义 ，**选择重传 （SR）** 协议通过让发送方仅重传那些它怀疑在接收方出错（ 即丢失或受损 ）的分组而避免了不必要的重传。 这种个别的 、 按需的重传要求接收方逐个地确认正确接收的分组 。再次用窗口长度 N来限制流水线中未完成 、 未被确认的分组数 。 然而， 与 GBN 不同的是 ， 发送方已经收到了对窗口中某些分组的 ACK 。 图 3-23 显示了 SR发送方看到的序号空间 。 图 3-24 详细描述了 SR 发送方所采取的动作。

![image-20220503135041517](https://gitee.com/cafory/images-store/raw/master/Image/202205031350606.png/)

SR 接收方将确认一个正确接收的分组而不管其是否按序 。 失序的分组将被缓存直到所有丢失分组（ 即序号更小的分组）皆被收到为止 ，这时才可以将一批分组按序交付给上层 。 图 3-25 详细列出了 SR 接收方所采用的各种动作。 图 3-26 给出了一个例子以说明出现丢包时 SR 的操作。值得注意的是 ， 在图 3 ・ 26 中接收方初始时缓存了分组 3 、 4 、 5，并在最终收到分组 2 时.才将它们一并交付给上层 。

![image-20220503135507804](https://gitee.com/cafory/images-store/raw/master/Image/202205031355910.png/)

![image-20220503135535238](https://gitee.com/cafory/images-store/raw/master/Image/202205031355342.png/)

注意到图 3-25 中的第二步很重要， 接收方重新确认（而不是忽略） 已收到过的那些序号小于当前窗口基序号的分组 。你应该理解这种重新确认确实是需要的 。例如 ，给定在图 3-23 中所示的发送方和接收方的序号空间， 如果分组 send_base 的 ACK 没有从接收方传播回发送方 ， 则发送方最终将重传分组 send_base， 即使显然 （ 对我们而不是对发送方来说! ） 接收方已经收到了该分组 。 如果接收方不确认该分组， 则发送方窗口将永远不能向
前滑动 ！这个例子说明了 SR 协议（ 和很多其他协议一样 ）的一个重要方面 。 对于哪些分组已经被正确接收 ， 哪些没有 ， 发送方和接收方并不总是能看到相同的结果 。 对 SR 协议而言，这就意味着发送方和接收方的窗口并不总是一致 。

当我们面对有限序号范围的现实时 ， 发送方和接收方窗口间缺乏同步会产生严重的后果 。 考虑下面例子中可能发生的情况 ，该例有包括 4 个分组序号 0 、 1 、 2 、 3 的有限序号范围且窗口长度为 3 。假定发送了分组 0 至 2, 并在接收方被正确接收且确认了。 此时，接收方窗口落在第 4 、 5 、 6 个分组上 ， 其序号分别为 3 、 0 、 1 。 现在考虑两种情况。 在第一种情况下 ， 如图 3-27a 所示， 对前 3 个分组的 ACK 丢失 ， 因此发送方重传这些分组 。 因此 ， 接收方下一步要接收序号为 0 的分组， 即第一个发送分组的副本 。

![image-20220503135809461](https://gitee.com/cafory/images-store/raw/master/Image/202205031358578.png/)

在第二种情况下 ， 如图 3-27b 所示， 对前 3 个分组的 ACK 都被正确交付。 因此发送方向前移动窗口并发送第 4 、 5 、 6 个分组， 其序号分别为 3 、 0 、 10 序号为 3 的分组丢失 ，但序号为 0 的分组到达（ 一个包含新数据的分组） 。

现在考虑一下图 3-27 中接收方的观点 ， 在发送方和接收方之间有一个假想的帘子，因为接收方不能 “ 看见 ”发送方采取的动作。 接收方所能观察到的是它从信道中收到的以及它向信道中发出报文序列。 就其所关注的而言， 图 3-27 中的两种情况是等同的 。 没有办法区分是第 1 个分组的重传还是第 5 个分组的初次传输 。 显然 ，窗口长度比序号空间小1 时协议无法工作。但窗口必须多小呢 ？ 对于 SR 协议而言，窗口长度必须小于或等于序号空间大小的一半。

至此我们结束了对可靠数据传输协议的讨论 。 我们已涵盖许多基础知识， 并介绍了多种机制 ，这些机制可一起提供可靠数据传输 。 表 3-1 总结这些机制。

![image-20220503135953256](https://gitee.com/cafory/images-store/raw/master/Image/202205031359369.png/)



## 3.5 面向连接的运输： TCP

TCP 是因特网运输层的面向连接的可靠的运输协议 。 我们在本节中将看到 ， 为了提供可靠数据传输， TCP 依赖于前一节所讨论的许多基本原理， 其中包括**差错检测 、 重传、 累积确认 、 定时器以及用于序号和确认号的首部字段** 。 TCP 定义在 RFC 793 、 RFC 1122 、 RFC 1323 、RFC 2018 以及 RFC 2581 中。

### 3.5.1 TCP 连接

TCP 被称为是**面向连接的（ connection-oriented ）**，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前 ，这两个进程必须先相互“ 握手 ” ， 即它们必须相互发送某些预备报文段 ， 以建立确保数据传输的参数 。作为 TCP 连接建立的一部分 ，连接的双方都将初始化与 TCP 连接相关的许多 TCP 状态变量。

这种 TCP “ 连接 ”不是一条像在电路交换网络中的端到端 TDM 或 FDM 电路 。 相反，该 “ 连接 ” 是一条**逻辑连接** ， 其共同状态仅保留在两个通信端系统的 TCP 程序中。前面讲过，由于 TCP 协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机 ） 中运行， 所以中间的网络元素不会维持 TCP 连接状态 。事实上 ， 中间路由器对 TCP连接完全视而不见， 它们看到的是数据包，而不是连接。

TCP 连接总是**点对点 （ point-to-point）** 的， 即在单个发送方与单个接收方之间的连接 。 所谓 “ 多播 ” ， 即在一次发送操作中 ， 从一个发送方将数据传送给多个接收方 ，这种情况对 TCP 来说是不可能的 。

我们现在来看看 TCP 连接是怎样建立的 。假设运行在某台主机上的一个进程想与另一台主机上的一个进程建立一条连接 。前面讲过， 发起连接的这个进程被称为**客户进程**，而另一个进程被称为**服务器进程** 。 该客户应用进程首先要通知客户运输层 ， 它想与服务器上的一个进程建立一条连接 。

客户首先发送一个特殊的 TCP 报文段 ， 服务器用另一个特殊的 TCP 报文段来响应 ， 最后 ， 客户再用第三个特殊报文段作为响应 。前两个报文段不承载 “ 有效载荷 ” ， 也就是不包含应用层数据 ；而第三个报文段可以承载有效载荷 。由于在这两台主机之间发送了 3 个报文段 ， 所以这种连接建立过程常被称为**三次握手（ three- way handshake ）** 。

![image-20220506141447793](https://gitee.com/cafory/images-store/raw/master/Image/202205061414869.png/)

一旦建立起一条 TCP 连接 ， 两个应用进程之间就可以相互发送数据了。客户进程通过套接字 （该进程之门） 传递数据流 。 数据一旦通过该门， 它就由客户中运行的 TCP 控制了。如图3-28所示， TCP 将这些数据引导到该连接的**发送缓存 （send buffer）**里， 发送缓存是发起三次握手期间设置的缓存之一。 接下来 TCP 就会不时从发送缓存里取出一块数据 ，并将数据传递到网络层 。TCP 可从缓存中取出并放入报文段中的数据数量受限于**最大报文段长度 （ Maximum Segment Size，MSS）**。 MSS 通常根据最初确定的由本地发送主机发送的最大链路层帧长度 （ 即所谓的**最大传输单元 （ Maximum Transmission Unit，MTU）**） 来设置 。 设置该 MSS 要保证一个 TCP报文段 （ 当封装在一个 IP 数据报中 ）加上 TCP/IP 首部长度 （通常 40 字节）将适合单个链路层帧 。以太网和 PPP 链路层协议都具有 1500 字节的 MTU，因此 MSS 的典型值为 1460字节 。TCP 为每块客户数据配上一个 TCP 首部， 从而形成多个 TCP 报文段 （ TCP segment ） 。这些报文段被下传给网络层 ，网络层将其分别封装在网络层 IP 数据报中。 然后这些 IP 数据报被发送到网络中。 当 TCP 在另一端接收到一个报文段后 ，该报文段的数据就被放入该TCP 连接的接收缓存中 ， 如图 3-28 中所示 。 应用程序从此缓存中读取数据流 。 该连接的每一端都有各自的发送缓存和接收缓存 。

从以上讨论中我们可以看出 ， TCP 连接的组成包括 ： 一台主机上的缓存 、变量和与进程连接的套接字 ， 以及另一台主机上的另一组缓存 、变量和与进程连接的套接字 。 如前面讲过的那样 ， 在这两台主机之间的网络元素（路由器、交换机和中继器）中没有为该连接分配任何缓存和变量 。

### 3.5.2 TCP 报文段结构

TCP 报文段由首部字段和一个数据字段组成 。 数据字段包含一块应用数据 。 如前所述， MSS 限制了报文段数据字段的最大长度 。 当 TCP 发送一个大文件 ， 例如某 Web 页面上的一个图像时 ， TCP 通常是将该文件划分成长度为 MSS 的若干块（最后一块除外 ， 它通常小于 MSS）。然而，交互式应用通常传送长度小于 MSS 的数据块 。

![image-20220506142203146](https://gitee.com/cafory/images-store/raw/master/Image/202205061422231.png/)

图 3 ・ 29 显示了 TCP 报文段的结构 。与UDP — 样 ，首部包括源端口号和目的端口号 ， 它被用于多路复用 /分解来自或送到上层应用的数据 。另外 ， 同 UDP — 样 ， TCP
首部也包括**检验和字段 ( checksum field )** 。TCP 报文段首部还包含下列字段:

+ 32 比特的**序号字段 （sequence number field）** 和 **32 比特的确认号字段 （acknowledgment number field）** 。 这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务 。
+ 16 比特的**接收窗口字段 ( receive window field )**， 该字段用于流量控制。 我们很快就会看到 ，该字段用于指示接收方愿意接受的字节数量 。
+ 4 比特的**首部长度字段 ( header length field )**， 该字段指示了以 32 比特的字为单位
  的 TCP 首部长度 。 由于 TCP 选项字段的原因 ， TCP 首部的长度是可变的 。(通常,
  选项字段为空， 所以 TCP 首部的典型长度是 20 字节 。)
+ 可选与变长的**选项字段 ( options field )**， 该字段用于发送方与接收方协商最大报文
  段长度 ( MSS) 时 ， 或在高速网络环境下用作窗口调节因子时使用 。 首部字段中
  还定义了一个时间戳选项 。
+ 6 比特的**标志字段 ( flag field )** 。ACK 比特用于指示确认字段中的值是有效的， 即
  该报文段包括一个对已被成功接收报文段的确认 。 RST 、 SYN 和 FIN 比特用于连
  接建立和拆除， 我们将在本节后面讨论该问题 。

1. **序号和确认号**

TCP 报文段首部中两个最重要的字段是序号字段和确认号字段 。 这两个字段是 TCP 可靠传输服务的关键部分。但是在讨论这两个字段是如何用于提供可靠数据传输之前 ， 我们首先来解释一下 TCP 在这两个字段中究竟放置了什么。

TCP 把数据看成一个无结构的 、 有序的字节流 。 我们从 TCP 对序号的使用上可以看出这一点 ， 因为序号是建立在传送的字节流之上 ，而不是建立在传送的报文段的序列之上。一个**报文段的序号 ( sequence number for a segment)** 因此是该报文段首字节的字节流编号。

举例来说， 假设主机 A 上的一个进程想通过一条 TCP 连接向主机 B 上的一个进程发送一个数据流 。主机 A 中的 TCP 将隐式地对数据流中的每一个字节编号。假定数据流由一个包含 500 000 字节的文件组成 ， 其 MSS 为 1000字节， 数据流的首字节编号是 0 。 如图 3-30所示，该 TCP 将为该数据流构建 500 个报文段 。 给第一个报文段分配序号 0，第二个报文段分配序号 1000， 第三个报文段分配序号 2000, 以此类推 。 每一个序号被填入到相应 TCP报文段首部的序号字段中。

![image-20220506142955015](https://gitee.com/cafory/images-store/raw/master/Image/202205061429086.png/)

现在我们考虑一下确认号。 确认号要比序号难处理一些。前面讲过， TCP 是全双工的，因此主机 A 在向主机 B 发送数据的同时 ， 也许也接收来自主机 B 的数据（都是同一条 TCP连接的一部分）。从主机 B 到达的每个报文段中都有一个序号用于从 B 流向 A 的数据 。**主机A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号**。 看一些例子有助于理解实际发生的事情 。假设主机 A 已收到了来自主机 B 的编号为 0 ~535 的所有字节， 同时假设它打算发送一个报文段给主机 B 。 主机 A 等待主机 B 的数据流中字节 536 及之后的所有字节 。所以主机 A 就会在它发往主机 B 的报文段的确认号字段中填上 536 。

再举一个例子 ， 假设主机 A 已收到一个来自主机 B 的包含字节 0 ~535 的报文段 ， 以及另一个包含字节 900 〜 1000 的报文段 。 由于某种原因 ， 主机 A 还没有收到字节 536 - 899 的报文段 。 在这个例子中 ， 主机 A 为了重新构建主机 B 的数据流 ， 仍在等待字节 536 （ 和其后的字节） 。 因此 ， A 到 B 的下一个报文段将在确认号字段中包含 536 。 因为 TCP 只确认该流中至第一个丢失字节为止的字节， 所以 TCP 被称为提供**累积确认（ cumulative acknowledgment ）** 。

最后一个例子也会引发一个重要而微妙的问题 。主机 A 在收到第二个报文段 （ 字节536 ~899 ） 之前收到第三个报文段 （ 字节 900 ~ 1000 ） 。 因此 ，第三个报文段失序到达 。
该微妙的问题是 ： 当主机在一条 TCP 连接中收到失序报文段时该怎么办 ？ 有趣的是 ，TCP的RFC 并没有为此明确规定任何规则 ，而是把这一问题留给实现 TCP 的编程人员去处理 。他们有两个基本的选择 ： ①接收方立即丢弃失序报文段 （ 如前所述，这可以简化接收方的设计）； ②接收方保留失序的字节， 并等待缺少的字节以填补该间隔 。 显然 ， 后一种选择对网络带宽而言更为有效 ， 是实践中采用的方法 。

在图 3-30 中 ， 我们假设初始序号为 0 。事实上 ， 一条 TCP 连接的双方均可随机地选择
初始序号。 这样做可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段 ，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性 （ 它碰巧与旧连接使用了相同的端口号 ）。

2. **Telnet ： 序号和确认号的一个学习案例**

详情请查阅书P156。

### 3.5.3 往返时间的估计与超时

TCP 如同前面 3. 4 节所讲的 rdt 协议一样 ， 它采用超时 / 重传机制来处理报文段的丢失问题 。 尽管这在概念上简单 ， 但是当在如 TCP 这样的实际协议中实现超时 / 重传机制时是会产生许多微妙的问题 。也许最明显的一个问题就是超时间隔长度的设置 。 显然 ，超间隔必须大于该连接的往返时间 （ RTT）, 即从一个报文段发出到它被确认的时间 。否则会造成不必要的重传。但是这个时间间隔到底应该是多大呢 ？ 刚开始时应如何估计往返时间呢 ？ 是否应该为所有未确认的报文段各设一个定时器 ？ 我们将在本节进行讨论。

+ **估计往返时间**

我们开始学习 TCP 定时器的管理问题，要考虑一下 TCP 是如何估计发送方与接收方之间往返时间的 。 这是通过如下方法完成的 。 报文段的样本 RTT （表示为 SampleRTT） 就是从某报文段被发出 （ 即交给 IP） 到对该报文段的确认被收到之间的时间量 。 大多数 TCP的实现仅在某个时刻做一次 SampleRTT 测量，而不是为每个发送的报文段测量一个 SampleRTT。 这就是说， 在任意时刻 ， 仅为一个已发送的但目前尚未被确认的报文段估计 SampleRTT， 从而产生一个接近每个 RTT 的新 SampleRTT 值。另外 ， TCP 决不为已被重传的报文段计算 SampleRTT ； 它仅为传输一次的报文段测量 。

显然 ，由于路由器的拥塞和端系统负载的变化 ，这些报文段的 SampleRTT 值会随之波
动。 由于这种波动 ， 任何给定的 SampleRTT 值也许都是非典型的 。 因此 ， 为了估计一个典型的 RTT， 自然要采取某种对 SampleRTT 取平均的办法 。 TCP 维持一个 SampleRTT 均值（称为 EstimatedRTT）。 一旦获得一个新 SampleRTT 时 ， TCP 就会根据下列公式来更新 Estimated RTT :

$$EstimatedRTT=(1-\alpha)\cdot EstimatedRTT+\alpha\cdot SampleRTT$$

EstimatedRTT 的新值是由以前的 EstimatedRTT 值与 SampleRTT 新值加权组合而成的 。在 ［ RFC 6298 ］ 中给岀的$\alpha$推荐值是$\alpha=0.125$ （ 即 1/8 ） , 这时上面的公式变为 ：

$$EstimatedRTT=0.875\cdot EstimatedRTT+0.125\cdot SampleRTT$$

值得注意的是 ， EstimatedRTT 是一个 SampleRTT 值的加权平均值，这个加权平均对最近的样本赋予的权值要大于对旧样本赋予的权值。这是很自然的， 因为越近的样本越能更好地反映网络的当前拥塞情况。从统计学观点讲，这种平均被称为**指数加权移动平均 （ Exponential Weighted Moving Average , EWMA）** 。

除了估算 RTT 外 ， 测量 RTT 的变化也是有价值的 。 ［RFC 6298］ 定义了 RTT 偏差DevRTT ，用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度 ：

$$DevRTT=(1-\beta)\cdot DevRTT+\beta \cdot |SampleRTT-EstimatedRTT|$$

注意到 DevRTT 是一个 SampleRTT 与 EstimatedRTT 之间差值的 EWMA 。 如果 Samp-
leRTT 值波动较小 ，那么 DevRTT 的值就会很小 ； 另一方面， 如果波动很大 ，那DevRTT
的值就会很大 。 $\beta$的推荐值为 0. 25 。

+ **设置和管理重传超时间隔**

假设已经给岀了 EstimatedRTT 值和 DevRTT 值 ，那么 TCP 超时间隔应该用什么值呢? 很明显 ，超时间隔应该大于等于 EstimatedR^IT, 否则 ， 将造成不必要的重传。但是超时间隔也不应该比 EstimatedRTT 大太多 ， 否则当报文段丢失时 ， TCP 不能很快地重传该报文段 ， 导致数据传输时延大 。 因此要求将超时间隔设为 EstimatedRTT 加上一定余量 。 当SampleRTT 值波动较大时 ，这个余量应该大些 ； 当波动较小时 ，这个余量应该小些。 因此 ， DevRTT 值应该在这里发挥作用了。 在 TCP 的确定重传超时间隔的方法中 ， 所有这些因素都考虑到了:

$$TimeoutInterval=EstimatedRTT+4\cdot DevRTT$$

推荐的初始 Timeoutinterval 值为 ］秒 ［RFC 6298］ 0 同时 ， 当出现超时后， Timeoutlnterval 值将加倍 ， 以免即将被确认的后继报文段过早出现超时 。 然而， 只要收到报文段并更新 EstimatedRTT, 就使用上述公式再次计算 TimeoutInterval。

### 3.5.4 可靠数据传输

TCP 在 IP 不可靠的尽力而为服务之上创建了一种**可靠数据传输服务（ reliable data transfer service）**。TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏 、无间隙 、 非冗余和按序的数据流 ； 即该字节流与连接的另一方端系统发送出的字节流是完全相同。

我们将以两个递增的步骤来讨论 TCP 是如何提供可靠数据传输的 。 我们先给出一个 TCP发送方的高度简化的描述，该发送方只用超时来恢复报文段的丢失 ； 然后再给岀一个更全面的描述，该描述中除了使用超时机制外 ，还使用冗余确认技术 。 在接下来的讨论中 ， 我们假定数据仅向一个方向发送， 即从主机 A 到主机 B, 且主机 A 在发送一个大文件。

图 3-33 给岀了一个 TCP 发送方高度简化的描述 。 我们看到在 TCP 发送方有 3 个与发送和重传有关的主要事件 ： 从上层应用程序接收数据 ； 定时器超时和收到 ACK 。 一旦第一个主要事件发生， TCP 从应用程序接收数据 ， 将数据封装在一个报文段中 ， 并把该报文段交给 IP 。 注意到每一个报文段都包含一个序号 ， 如 3.5.2 节所讲的那样 ，这个序号就是该报文段第一个数据字节的字节流编号。 还要注意到如果定时器还没有为某些其他报文段而运行， 则当报文段被传给 IP 时 ， TCP 就启动该定时器。 （ 将定时器想象为与最早的未被确认的报文段相关联是有帮助的 。 ）该定时器的过期间隔是 Timeoutinterval , 它是由 3.5.3 节中所描述的 EstimatedRTT 和 DevRTT 计算得出的 。

![image-20220506150749845](https://gitee.com/cafory/images-store/raw/master/Image/202205061511597.png/)

第二个主要事件是超时 。 TCP 通过重传引起超时的报文段来响应超时事件。 然后 TCP重启定时器。

TCP 发送方必须处理的第三个主要事件是 ， 到达一个来自接收方的确认报文段 （ ACK）（ 更确切地说， 是一个包含了有效 ACK 字段值的报文段 ） 。 当该事件发生时 ， TCP 将 ACK 的值 y 与它的变量 SendBase 进行比较 。 TCP 状态变量 SendBase 是最早未被确认的字节的序号。（ 因此 SendBase - 1 是指接收方已正确按序接收到的数据的最后一个字节的序号。 ） 如前面指出的那样 ， TCP 采用累积确认， 所以 y 确认了字节编号在 y 之前的所有字节都已经收到。 如果 y > SendBase , 则该 ACK 是在确认一个或多个先前未被确认的报文段 。 因此发送方更新它的 SendBase 变量； 如果当前有未被确认的报文段 ， TCP 还要重新启动定时器。
