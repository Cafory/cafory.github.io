---
title: 计算机网络-03
tags: Network
---

# 第三章 运输层

运输层位于应用层和网络层之间， 是分层的网络体系结构的重要部分。 该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用 。 我们在本章采用的教学方法是 ， 交替地讨论运输层的原理和这些原理在现有的协议中是如何实现的 。与往常一样 ， 我们将特别关注因特网协议， 即 TCP 和 UDP 运输层协议 。



<!--more-->

## 3.1 概述和运输层服务

> 运输层负责[端到端](https://baike.baidu.com/item/端到端/8851783)的通信，既是七层模型中负责[数据通信](https://baike.baidu.com/item/数据通信/897073)的最高层，又是面向网络通信的低三层和面向信息处理的最高三层之间的中间层。运输层位于网络层之上、[会话层](https://baike.baidu.com/item/会话层/4329656)之下，它利用网络层子系统提供给它的服务去开发本层的功能，并实现本层对会话层的服务。【来源：[百度百科](https://baike.baidu.com/item/%E8%BF%90%E8%BE%93%E5%B1%82/9094793?fr=aladdin)】

运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信 （ logic communica­tion） 功能 。从应用程序的角度看，通过逻辑通信 ，运行不同进程的主机好像直接相连一样 ； 实际上 ，这些主机也许位于地球的两侧 ，通过很多路由器及多种不同类型的链路相连 。

![2022-05-01 21-17-11 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012118806.png/)

如图 3-1所示，运输层协议是在端系统中而不是在路由器中实现的 。 在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层**报文段 （ segment）**。

网络应用程序可以使用多种的运输层协议 。例如 ， 因特网有两种协议， 即 TCP 和UDP 。 每种协议都能为调用的应用程序提供一组不同的运输层服务。

### 3.1.1 运输层和网络层的关系

在协议栈中 ，运输层刚好位于网络层之上。 网络层提供了**主机之间**的逻辑通信 ，而运输层为运行在不同主机上的**进程之间**提供了逻辑通信。

> 我们用一个家庭类比来帮助分析上述差别。
>
> 考虑有两个家庭 ， 一家位于美国东海岸 ， 一家位于美国西海岸 ， 每家有 12 个孩子 。东海岸家庭的孩子们是西海岸家庭孩子们的堂兄弟姐妹 。 这两个家庭的孩子们喜欢彼此通信 ， 每个人每星期要互相写一封信 ， 每封信都用单独的信封通过传统的邮政服务传送 。 因此 ， 每个家庭每星期向另一家发送 144 封信。 （ 如果他们有电子邮件的话，这些孩子可以省不少钱！） 每一个家庭有个孩子负责收发邮件 ，西海岸家庭是 Ann 而东海岸家庭是 Bill 。每星期 Ann 去她的所有兄弟姐妹那里收集信件 ， 并将这些信件交到每天到家门口来的邮政服务的邮车上。 当信件到达西海岸家庭时 ， Ann 也负责将信件分发到她的兄弟姐妹手上。在东海岸家庭中的 Bill 也负责类似的工作。
>
> 在这个例子中 ，邮政服务为两个家庭间提供逻辑通信 ，邮政服务将信件从一家送往另一家 ，而不是从一个人送往另一个人。 在另一方面， Ann 和 Bill 为堂兄弟姐妹之间提供了逻辑通信 ， Arm 和 Bill 从兄弟姐妹那里收取信件或到兄弟姐妹那里交付信件。 注意到从堂兄弟姐妹们的角度来看， Ann 和 Bill 就是邮件服务 ， 尽管他们只是端到端交付过程的一部分 （ 即端系统部分 ） 。 在解释运输层和网络层之间的关系时 ，这个家庭的例子是一个非常好的类比 。
>
> + 应用层报文 = 信封上的字符
> + 进程 = 堂兄弟姐妹
> + 主机 （ 又称为端系统） = 家庭
> + 运输层协议 = Ann 和 Bill
> + 网络层协议 = 邮政服务 （ 包括邮车）
>
> 我们继续观察这个类比 。值得注意的是 ， Ann 和 Bill 都是在各自家里进行工作的； 例如 ， 他们并没有参与任何一个中间邮件中心对邮件进行分拣 ， 或者将邮件从一个邮件中心送到另一个邮件中心之类的工作。 类似地 ，运输层协议只工作在端系统中。 在端系统中 ，运输层协议将来自应用进程的报文移动到网络边缘（ 即网络层 ）， 反过来也是一样 ， 但对有关这些报文在网络核心如何移动并不作任何规定 。事实上 ， 如图 3-1 所示， 中间路由器既不处理也不识别运输层加在应用层报文的任何信息 。
>
> 我们还是继续讨论这两家的情况。 现在假定 Ann 和 Bill 外出度假 ， 另外一对堂兄妹（ 如 Susan 和 Harvey） 接替他们的工作 ， 在家庭内部进行信件的收集和交付工作。不幸的是 ， Susan 和 Harvey 的收集和交付工作与 Ann 和 Bill 所做的并不完全一样 。 由于年龄更小 ， Susan 和 Harvey 收发邮件的次数更少 ，而且偶尔还会丢失邮件 （ 有时是被家里的狗咬坏了 ） 。 因此 ， Susan 和 Harvey 这对堂兄妹并没有提供与 Ann 和 Bill 一样的服务集合 （ 即相同的服务模型 ） 。与此类似，计算机网络中可以安排多种运输层协议，每种协议为应用程序提供不同的服务模型 。

运输协议能够提供的服务常常受制于底层网络层协议的服务模型 。 如果网络层协议无法为主机之间发送的运输层
报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证 。

然而， 即使底层网络协议不能在网络层提供相应的服务 ，运输层协议也能提供某些服务。例如 ， 如我们将在本章所见， 即使底层网络协议是不可靠的， 也就是说网络层协议会使分组丢失 、 篡改和冗余 ，运输协议也能为应用程序提供可靠的数据传输服务。

### 3.1.2 因特网运输层概述

因特网为应用层提供了两种截然不同的可用运输层协议 。 

+ 一种是UDP （用户数据报协议）， 它为调用它的应用程序提供了一种不可靠 、 无连接的服务。
+ 另一种是 TCP （ 传输控制协议）， 它为调用它的应用程序提供了一种可靠的 、 面向连接的服务。

应用程序开发人员在生成套接字时必须指定是选择 UDP 还是选择 TCP 。

为了简化术语， 我们将运输层分组称为**报文段 ( segment)** 。 然而， 因特网文献(如RFC 文档)常将 UDP 的分组称为**数据报 ( data-gram )** 。 而这类因特网文献也将网络层分组称为数据报 ！ 在这里， 我们认为将 TCP 和 UDP 的分组统称为报文段 ，而将数据报名称保留给网络层分组不容易混淆 。

> 在对 UDP 和 TCP 进行简要介绍之前 ，简单介绍一下因特网的网络层。 因特网网络层协议有一个名字叫 IP, 即网际协议 。 IP为主机之间提供了逻辑通信。 IP 的服务模型是**尽力而为交付服务( best- effort delivery serv­ice)** 。 这意味着 IP 尽它 “ 最大的努力” 在通信的主机之间交付报文段 ， 但它并不做任何确保。 特别是 ， 它不确保报文段的交付 ， 不保证报文段的按序交付 ， 不保证报文段中数据的完整性 。 由于这些原因 ， IP 被称为**不可靠服务 ( unreliable service)** 。 在此还要指出的是，每台主机至少有一个**网络层地址** ， 即所谓的 **IP 地址** ，每台主机有一个 IP 地址 。

UDP 和 TCP 最基本的责任是 ， 将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。 将主机间交付扩展到进程间交付被称为运输层的**多路复用（transport-layer multiplexing）** 与**多路分解(demultiplexing)** 。

UDP 和 TCP 还可以通过在其报文段首部中包括差错检查字段而提供完整性检查 。

进程到进程的数据交付和差错检查是两种最低限度的运输层服务 ， 也是UDP 所能提供的仅有的两种服务。

TCP 为应用程序提供了几种附加服务：

+ **可靠数据传输（reliable data transfer）。** 通过使用流量控制、 序号、 确认和定时器，TCP 确保正确地 、 按序地将数据从发送进程交付给接收进程 。
+ **拥塞控制 ( comgestion control ) 。**TCP 拥塞控制防止任何一条 TCP 连接用过多流量来淹没通信主机之间的链路和交换设备 。 TCP 力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽 。 这可以通过调节 TCP 连接的发送端发送进网络的流量速率来做到。



## 3.2 多路复用与多路分解

运输层的多路复用与多路分解是将由网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务。需要强调的是 ， 多路复用与多路分解服务是所有计算机网络都需要的 。

在目的主机 ，运输层从紧邻其下的网络层接收报文段 。 运输层负责将这些报文段中的数据交付给在主机上运行的适当应用程序进程 。 我们来看一个例子 。假定你正坐在计算机前下载 Web 页面， 同时还在运行一个 FTP 会话和两个 Telnet 会话 。 这样你就有 4 个网络应用进程在运行， 即两个 Telnet 进程， 一个 FTP 进程和一个 HTTP 进程 。 当你的计算机中的运输层从底层的网络层接收数据时 ， 它需要将所接收到的数据定向到这 4 个进程中的一
个。 现在我们来研究这是怎样完成的 。

首先回想 第2章的内容 ， 一个进程(作为网络应用的一部分)有一个或多个**套接字(socket)**， 它相当于从网络向进程传递数据和从进程向网络传递数据的门户 。 因此 ， 如图 3-2 所示， 在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字 。 由于在任一时刻 ， 在接收主机上可能有不止一个套接字 ， 所以每个套接字都有唯一的标识符 。 标识符的格式取决于它是 UDP 还是 TCP 套接字 ， 我们将很快对它们进行讨论 。

![2022-05-01 22-28-43 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012228650.png/)

现在我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字 。为此目的， 每个运输层报文段中具有几个字段 。 在接收端，运输层检查这些字段 ， 标识出接收套接字 ，进而将报文段定向到该套接字 。 将运输层报文段中的数据交付到正确的套接字的工作称为**多路分解 ( demultiplexing)** 。 在源主机从不同套接字中收集数据块 ， 并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段 ， 然后将报文段传递到网络层 ， 所有这些工作称为**多路复用 ( multiplexing)** 。

通过上述讨论， 我们知道运输层多路复用要求 ： ①套接字有唯一标识符；②每个报文段有特殊字段来指示该报文段所要交付到的套接字 。

![2022-05-01 22-37-51 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012238859.png/)

如图3-3所示，这些特殊字段是**源端口号字段 ( source port number field )** 和目**的端口号字段 ( destination port number field)** 。

端口号是一个 16 比特的数 ， 其大小在 0 ~ 65535 之间 。 0 ~ 1023 范围的端口号称为**周知端口号( well-known port number)**，是受限制的，这是指它们保留给诸如 HTTP (它使用端口号 80) 和 FTP (它使用端口号 21) 之类的周知应用层协议来使用 。

现在应该清楚运输层是怎样能够实现分解服务的了 ： 在主机上的每个套接字能够分配一个端口号 ， 当报文段到达主机时 ，运输层检査报文段中的目的端口号 ， 并将其定向到相应的套接字 。 然后报文段中的数据通过套接字进入其所连接的进程 。 如我们将看到的那样 ， UDP 大体上是这样做的 。 然而， 也将如我们所见， TCP 中的多路复用与多路分解更为复杂 。

1. **无连接的多路复用与多路分解**

   假定在主机 A 中的一个进程具有 UDP 端口 19157, 它要发送一个应用程序数据块给位于主机B 中的另一进程，该进程具有 UDP 端口 46428。主机 A 中的运输层创建一个运输层报文段 ， 其中包括应用程序数据 、 源端口号 （ 19157 ） 、 目的端口号 （ 46428 ） 和两个其他值。 然后 ，运输层将得到的报文段传递到网络层 。 网络层将该报文段封装到一个 IP数据报中 ， 并尽力而为地将报文段交付给接收主机 。如果该报文段到达接收主机 B, 接收主机运输层就检查该报文段中的目的端口号 （ 46428 ）并将该报文段交付给端口号46428 所标识的套接字 。值得注意的是 ， 主机 B 可能运行多个进程， 每个进程都具有其自己的 UDP 套接字和相联系的端口号。 当 UDP 报文段从网络到达时 ， 主机 B 通过检查该报文段中的目的端口号 ， 将每个报文段定向 （ 分解） 到相应的套接字 。

   一个 UDP 套接字是由一个二元组全面标识的，该二元组包含一个目的IP 地址和一个目的端口号。 因此，如果两个 UDP 报文段有不同的源 IP 地址和/ 或源端口号 ， 但具有相同的目的 IP 地址和目的端口号 ，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程 。

   源端口号的用途是什么呢 ？ 如图 3-4 所示， 在 A 到 B 的报文段中，源端口号用作“ 返回地址"的一部分 ， 即当 B 需要回发一个报文段给 A 时 ， B 到 A 的报文段中的目的端口号便从 A 到 B 的报文段中的源端口号中取值。 （ 完整的返回地址是 A 的 IP 地址和源端口号。 ）

   ![2022-05-01 22-46-53 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012247189.png/)

2.  **而向连接的多路复用与多路分解**

   TCP 套接字是由一个四元组（ **源 IP 地址，源端口号 ，目的 IP 地址 ，目的端口号** ） 来标识的 。 因此 ， 当一个 TCP 报文段从网络到达一台主机时 ，该主机使用全部 4 个值来将报文段定向 （ 分解） 到相应的套接字 。 特别与UDP 不同的是 ， 两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字 ，除非 TCP 报文段携带了初始创建连接的请求 。
   
   服务器主机可以支持很多并行的 TCP 套接字 ， 每个套接字与一个进程相联系， 并由其四元组来标识每个套接字 。 当一个 TCP 报文段到达主机时 ， 所有 4 个字段 （ 源 IP 地址,源端口 ，目的 IP 地址 ，目的端口 ）被用来将报文段定向 （ 分解） 到相应的套接字 。
   
   图 3-5 图示了这种情况 ， 图中主机 C 向服务器 B 发起了两个 HTTP 会话， 主机 A 向服务器 B 发起了一个 HTTP 会话 。主机 A 与主机 C 及服务器 B 都有自己唯一的 IP 地址 ， 它们分别是 A 、 C 、 B 。 主机 C 为其两个 HTTP 连接分配了两个不同的源端口号 （ 26145 和7532 ） 。 因为主机 A 选择源端口号时与主机 C 互不相干 ， 因此它也可以将源端口号 26145分配给其 HTTP 连接 。但这不是问题， 即服务器 B 仍然能够正确地分解这两个具有相同源端口号的连接 ， 因为这两条连接有不同的源 IP 地址 。

![2022-05-01 22-59-34 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205012259877.png/)

## 3.3 无连接运输

UDP 从应用进程得到数据 ，附加上用于多路复用 /分解服务的源和目的端口号字段 ， 以及两个其他的小字段,
然后将形成的报文段交给网络层 。 网络层将该运输层报文段封装到一个 IP 数据报中 ， 然后尽力而为地尝试将此报文段交付给接收主机 。 如果该报文段到达接收主机 ， UDP 使用目的端口号将报文段中的数据交付给正确的应用进程 。值得注意的是 ， 使用 UDP 时 ， 在发送报文段之前 ， 发送方和接收方的运输层实体之间没有握手 。 正因为如此 ， UDP 被称为是**无连接的** 。

DNS 是一个通常使用 UDP 的应用层协议的例子 。 当一台主机中的 DNS 应用程序想要进行一次查询时 ， 它构造了一个 DNS 查询报文并将其交给 UDP 。 无须执行任何与运行在目的端系统中的 UDP 实体之间的握手 ， 主机端的 UDP 为此报文添加首部字段 ， 然后将形成的报文段交给网络层。 网络层将此 UDP 报文段封装进一个 IP 数据报中 ， 然后将其发送给一个名字服务器。 在查询主机中的 DNS 应用程序则等待对该查询的响应 。 如果它没有
收到响应 （ 可能是由于底层网络丢失了查询或响应 ）， 则要么试图向另一个名字服务器发送该査询，要么通知调用的应用程序它不能获得响应 。

UDP相比于TCP的优点

+ **关于发送什么数据以及何时发送的应用层控制更为精细 。**
+ **无须连接建立 。**
+ **无连接状态 。**
+ **分组首部开销小 。**

### 3.3.1 UDP报文段结构

UDP 报文段结构如图 3-7 所示， 它由 RFC 768 定义。 应用层数据占用 UDP 报文段的数据字段 。

![2022-05-02 14-14-01 的屏幕截图](https://gitee.com/cafory/images-store/raw/master/Image/202205021414539.png/)

UDP 首部只有 4 个字段 ， 每个字段由两个字节组成 。 如前一节所讨论的，通过**端口号**可以使目的主机将应用数据交给运行在目的端系统中的相应进程（ 即执行分解功能） 。 **长度字段**指示了在 UDP 报文段中的字节数 （首部加数据 ） 。 因为数据字段的长度在一个 UDP 段中不同于在另一个段中 ， 故需要一个明确的长度 。接收方使用**检验和**来检查在该报文段中是否出现了差错 。 实际上 ，计算检验和时 ，除了 UDP 报文段以外还包括了 IP 首部的一些字段 。

### 3.3.2 UDP检验和

UDP 检验和提供了差错检测功能 。 这就是说， 检验和用于确定当 UDP 报文段从源到达目的地移动时 ， 其中的比特是否发生了改变 。发送方的 UDP 对报文段中的所有 16 比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。 得到的结果被放在 UDP 报文段中的检验和字段 。

举例来说， 假定我们有下面 3个 16 比特的字 ：

> 0110011001100000
> 0101010101010101
> 1000111100001100

这些 16 比特字的前两个之和是 ：

> 0110011001100000
> 0101010101010101
>
> ____________________
>
> 1011101110110101

再将上面的和与第三个字相加 ， 得出 ：

> 1011101110110101
> 1000111100001100
>
> ----------------------------------
>
> 0100101011000010

注意到最后一次加法有溢出 ， 它要被回卷。反码运算就是将所有的 0 换成 1， 所有的1 转换成 0 。 因此,该和 0100101011000010 的反码运算结果是 1011010100111101, 这就变为了检验和。 在接收方 ， 全部的 4 个 16 比特字 （ 包括检验和 ） 加在一起 。 如果该分组中没有引入差错， 则显然在接收方处该和将是1111111111111111 。如果这些比特之一是 0，那么我们就知道该分组中已经出现了差错 。

你可能想知道为什么 UDP 首先提供了检验和 ， 就像许多链路层协议（ 包括流行的以太网协议） 也提供了差错检测那样 。其原因是不能保证源和目的之间的所有链路都提供差错检测 ；这就是说， 也许这些链路中的一条可能使用没有差错检测的协议 。 此外 ， 即使报文段经链路正确地传输， 当报文段存储在某台路由器的内存中时 ， 也可能引入比特差错 。在既无法确保逐链路的可靠性 ， 又无法确保内存中的差错检测的情况下 ， 如果端到端数据传输服务要提供差错检测 ， UDP 就必须在端到端基础上在运输层提供差错检测 。 这是一个在系统设计中被称颂的**端到端原则 （ end-encl principle）** 的例子,该原则表述为因为某种功能（ 在此时为差错检测 ） 必须基于端到端实现： “与在较高级别提供这些功能的代价相比 ，在较低级别上设置的功能可能是冗余的或几乎没有价值的 。”
