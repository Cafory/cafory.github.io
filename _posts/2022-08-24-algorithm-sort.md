---
title: 数据结构与算法 排序算法
tags: algorithm
---



# 常用的排序算法

今天被米哈游面试的算法题难住了，利用快速排序解决从无序队列中找出的第k小的值，然而调了一个多小时都没有调出来。所以本篇对常用的排序算法进行归纳总结，熟悉一下经典排序的思想与代码。

<!--more-->

以下算法皆是将无序数组排序为升序数组，实现语言为C++。



### 1 冒泡排序

+ 算法原理：

    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

    2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

    3. 针对所有的元素重复以上的步骤，除了最后一个。

    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

    动图如下：

    ![](/My_Assets/bubbleSort.gif)

+ 代码实现

    ```cpp
    void bubbleSort(vector<int> & nums)
    {
        int N = nums.size();
        for(int i = 0 ; i < N - 1 ; i++ )
        {
            // 外层循环控制次数，总共比较N - 1 趟
            // 每趟可以确定一个数的位置
            for(int j = 0; j < N - 1 - i ; j++ )
            {
                // 内层循环控制每趟比较的元素
                // 第i趟循环可以确定后i个元素
                // 故j每趟循环范围为 [0, N - 1 - i]
                if( nums[j] > nums[j+1] )
                    swap(nums[j], nums[j+1]);
            }
        }
    }
    ```

### 2 选择排序

+ 算法原理：

    1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

    2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

    3. 重复第二步，直到所有元素均排序完毕。

    动图如下：

    ![]( /My_Assets/selectionSort.gif )

+ 代码实现：

    ```cpp
    void selectionSort(vector<int> &nums)
    {
        int min_i; // 保存未排序序列的最小值的下标
        for (int i = 0; i < nums.size(); i++)
        {
            // 外层循环控制获取第 i 小的值的下标
            min_i = i; // 将min_i重置为当前未排序序列的第一个下标
            for (int j = i; j < nums.size(); j++)
            {
                // 获取未排序序列的最小值下标
                if (nums[j] < nums[min_i])
                    min_i = j;
            }
            swap(nums[i], nums[min_i]);
        } 
    }
    ```

### 3 插入排序

+ 算法原理：

    插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

    具体步骤：

    1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

    2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

    3. 重复上述步骤直至完成排序。

    动图如下：

    ![](/My_Assets/insertionSort.gif)

+ 代码实现

    ```cpp
    void insertionSort(vector<int> & nums)
    {
        int j = 0, tmp;
        for( int i = 0 ; i < nums.size() ; i++ )
        {
            // 外层循坏控制目前是确定第i个元素的位置
            j = i;  // 保存第 i 个 元素的值
            tmp = nums[i];
            while( j >= 1 && tmp < nums[j - 1] )
            {
                // 当前一个位置大于待排序元素时，后移
                nums[j ] = nums[j - 1];
                j--;
            }
            // 找到正确的位置
            nums[j] = tmp;    
        }
    }
    ```

### 4 希尔排序

+ 算法原理：

    希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

    希尔排序是基于插入排序的以下两点性质而提出改进方法的：

    插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

    希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

    步骤如下：

    1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

    2. 按增量序列个数 k，对序列进行 k 趟排序；

    3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

    动图如下：

    ![](/My_Assets/shellSort.gif#pic_center)

    

    


